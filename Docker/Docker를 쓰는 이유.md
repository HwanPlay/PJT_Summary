# Docker를 왜 써야 하나요??

[참고 자료](https://www.44bits.io/ko/post/why-should-i-use-docker-container)

[44bits.io/도커 입문](https://www.44bits.io/ko/post/easy-deploy-with-docker)



컨테이너는 애플리케이션을 환경에 구애 받지 않고 실행하는 기술

도커는 리눅스 상에서 **컨테이너 방식**으로 **프로세스**를 격리해서 실행하고 관리할 수 있도록 도와주며, 계층화된 파일 시스템에 기반해 **효율적으로 이미지(프로세스 실행 환경)을 구축**할 수 있도록 해줍니다. 도커를 사용하면 이 **이미지를 기반으로 컨테이너를 실행**할 수 있으며, 다시 **특정 컨테이너의 상태를 변경해 이미지**로 만들 수 있습니다. 이렇게 만들어진 이미지는 파일로 보관하거나 원격 저장소를 사용해 쉽게 공유할 수 있으며, **도커만 설치되어 있다면 필요할 때 언제 어디서나 컨테이너로 실행**하는 것이 가능합니다.



## Why:question:

**도커 없이도 배포/운영하고 있는데, 우린 아무 불편을 느끼지 못합니다.**
**왜 도커를 써야 하죠?**



### 운영하면서 만들어지는 눈송이 서버들(Snowflake Servers)



1. 똑같은 일을 하는 두 서버가 있다 해도, A 서버는 한 달 전에 구성했고 B 서버는 이제 막 구성했다면, 운영체제부터 컴파일러, 설치된 패키지까지 완벽하게 같기는 쉽지 않습니다.
2. **A 서버는 잘 되는데 B 서버는 왜 죽었지?**
3. 서로 모양이 다른 서버들이 존재하는 상황을 **눈송이 서버(Snowflakes Server)**이라고도 합니다.



### Dockerfile

> 서버 운영 기록을 코드화한 것

```dockerfile
# Nginx 서버를 구성하는 도커 파일
FROM debian:stretch-slim

RUN apt-get update \
    && apt-get install -y \
    imagemagick  
```



- 도커 파일 = 서버 운영 기록 코드화 
- 도커 이미지 = 도커 파일 + 실행 시점
- 도커에서는 앞서 살펴본 도커 파일로 이미지를 만들어 두면, 서버가 구성되는 시점이 이미지를 만든 시점으로 고정됩니다.



![Docker 설명 Image](images/Docker_explain.m.png)

------





## 테스트 주도 개발의 관점에서 도커파일 바라보기



TDD: Test Driven Development



1. 도커 파일을 만들고
2. 도커 이미지 만들기에 실패하고,
3. 도커 파일을 작성/수정한 후,
4. 도커 이미지 만드는 데 성공합니다.
5. 필요 없는 부분은 지우고 합칠 수 있는 명령은 합칩니다. (=효율화)
6. 1번으로 돌아갑니다.



![Dockerfile 작성 순환](images/54855bc2f1cbd3143832027cbbe7e651cee964e8ac83a9d86e93b75c06bccb06.m.png)



```dockerfile
# Dockerfile
FROM ubuntu:latest  # 기반 이미지

RUN apt update
RUN apt install -y imagemagick
```



> TIP
>
> 기반 이미지로 컨테이너를 하나 실행한 다음 거기서 원하는 명령어들을 입력하고 원하는 결과가 나왔을 때 해당 명령어를 도커 파일로 옮기는 식으로 작업하면 실패 -> 수정 과정을 훨씬 더 빨리 반복할 수 있습니다.



빌드

```bash
$ docker build -t my-imagemagick .
... (중략) ...
Successfully tagged my-imagemagick:latest
```



이미지로 서버에서 실행

```bash
$ docker run -d my-imagemagick
... (중략) ...
```



컨테이너를 언제 실행하든 이미지가 변하지 않았다면 컨테이너의 내용도 완전히 똑같습니다. 

배포(혹은 실행)하는 시점과 상관 없이 서버의 내용을 똑같게 만들 수 있다.



### 클래스와 인스턴스처럼 도커 이미지 바라보기

1. 도커 이미지로는 언제든 **똑같은 형태의 서버를 실행(=도커 컨테이너)**할 수 있다. 
2. 그런데 코드나 도커 파일을 전혀 수정하지 않은 채 **내일 도커 이미지를 빌드**하면??
3. 서버가 똑같기를 기대하겠지만 **실제로는 달라질 수도** 있다. 
4. 왜냐하면, 서버에 설치하는 패키지가 하루 사이에 패치되었거나 할 수 있다.



#### :question:그러면 장점이 뭘까?

1. 지금까지 서버를 똑같이 만드는데 노력을 기울였다.
2. 하지만, 서버에서는 바뀌어야 할 부분도 있다.
3. Container Id, Container name, IP와 같은 부분들을 환경변수에 넣어 관리하도록 권한다.
4. 소프트웨어 분야의 클래스와 public 변수, private 변수에 비견할 수 있습니다.

![소프트웨어와 비교해 본 도커 이미지](images/bc718884a4278b663d4225a66886603b1e2f183841f2b09611cd24048105a71d.m.png)

```markdown
도커 파일 == 서버 운영 기록
도커 이미지 == 도커 파일 + 실행 시점
도커 컨테이너 == 도커 이미지 + 환경 변수
```



### 서버 코드화의 장점

1. 서버 제작 과정에 견고함과 유연성을 더할 뿐 아니라(환경변수, Dockerfile, build 시간)
2. 다른 이가 만든 서버를 소프트웨어 사용하듯 가져다 쓸 수 있고(Docker Hub)
3. 여러 대에 배포할 수 있는 확장성(Image를 통해 가능)

